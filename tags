local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")
local crequest =
    syn and syn.request or request or fluxus and fluxus.request or http and http.request or http_request or
    sentinel and sentinel.request or
    http_request or
    http.request or
    http and http.request or
    http_request or
    (crypt and crypt.request) or
    request or
    (SENTINEL_LOADED and request) or
    (syn and syn.request) or
    (typeof(request) == "function" and request) or
    (typeof(http) == "table" and http.request)
local JSON_URL = "https://0x0.st/8C5Z.json"
local MAX_RETRIES = 3

local function fetchList(url2, maxRetries)
    local retries = 0
    while retries < maxRetries do
        local success, result =
            pcall(
            function()
                return crequest(
                    {
                        Url = url2,
                        method = "GET"
                    }
                )
            end
        )
        if success then
            return true, result.Body
        end
        retries = retries + 1
        if retries < maxRetries then
            local delay = 2 ^ (retries - 1)
            task.wait(delay)
        end
    end
    return false, ""
end

local success, tagConfigRaw = fetchList(JSON_URL, MAX_RETRIES)
local tagConfig = {}
local lastConfigHash = ""
if success and tagConfigRaw then
    local parseSuccess, parsedData =
        pcall(
        function()
            return HttpService:JSONDecode(tagConfigRaw)
        end
    )
    if parseSuccess and parsedData then
        tagConfig = parsedData
        lastConfigHash = HttpService:JSONEncode(parsedData)
    end
end

local tagOrder = {"AL OWNER", "AL BOOSTER", "AL SWASTIKA", "AL MANGO", "AL SIGMA", "AL GAY", "AL FART", "AL CHIPS", "AL RONALDU", "AL USER", "AL MZWSyn2", "AL danYT", "AL c00lkid"}
local playerToTag = {}
for _, tag in ipairs(tagOrder) do
    local users = tagConfig[tag]
    if users then
        for _, user in ipairs(users) do
            local userLower = user:lower()
            if not playerToTag[userLower] then
                playerToTag[userLower] = tag
            end
        end
    end
end

local function containsIgnoreCase(tbl, name)
    if not name then
        return false
    end
    name = name:lower()
    for _, v in ipairs(tbl) do
        if v:lower() == name then
            return true
        end
    end
    return false
end

local function HSVtoRGB(h, s, v)
    local r, g, b
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    local imod = i % 6
    if imod == 0 then
        r, g, b = v, t, p
    elseif imod == 1 then
        r, g, b = q, v, p
    elseif imod == 2 then
        r, g, b = p, v, t
    elseif imod == 3 then
        r, g, b = p, q, v
    elseif imod == 4 then
        r, g, b = t, p, v
    elseif imod == 5 then
        r, g, b = v, p, q
    end

    return r, g, b
end

local CONFIG = {
    TAG_SIZE = UDim2.new(0, 0, 0, 32),
    TAG_OFFSET = Vector3.new(0, 2.0, 0),
    MAX_DISTANCE = 200000,
    DISTANCE_THRESHOLD = 50,
    HYSTERESIS = 5,
    TELEPORT_DISTANCE = 5,
    CORNER_RADIUS = UDim.new(0, 10),
    PARTICLE_COUNT = 100,
    PARTICLE_SPEED = 1,
    GLOW_INTENSITY = 0.3,
    TELEPORT_HEIGHT = 0.5,
    AFK_TIME_THRESHOLD = 300,
    AFK_CHECK_INTERVAL = 1
}

local RankData = {
    ["AL OWNER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = true,
        WaveText = false,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 200, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(150, 100, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 100, 255))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=110638600335178"
    },
    ["AL BOOSTER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = false,
        WaveText = true,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(135, 206, 250)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(173, 216, 230)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 182, 193))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=104877509615956"
    },
    ["AL RONALDU"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = true,
        WaveText = false,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(20, 20, 20)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(100, 50, 150)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(128, 0, 128))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=72736122747722"
    },
    ["AL GAY"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = true,
        UseImage = false,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
            ColorSequenceKeypoint.new(0.16, Color3.fromRGB(255, 165, 0)),
            ColorSequenceKeypoint.new(0.33, Color3.fromRGB(255, 255, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)),
            ColorSequenceKeypoint.new(0.66, Color3.fromRGB(0, 0, 255)),
            ColorSequenceKeypoint.new(0.83, Color3.fromRGB(75, 0, 130)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(148, 0, 211))
        },
        emoji = "🏳️‍🌈",
        image = ""
    },
    ["AL danYT"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(128, 0, 192)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=109142786823897"
    },
    ["AL c00lkid"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = true,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(128, 0, 0)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=138873111899938"
    },
    ["AL MZWSyn2"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = false,
        WaveText = true,
        MatrixText = false,
        RainbowText = false,
        UseImage = false,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(192, 0, 128)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(128, 0, 128))
        },
        emoji = "🍒",
        image = ""
    },
    ["AL SWASTIKA"] = {
        primary = Color3.fromRGB(0, 0, 0),
        AnimateName = true,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = false,
        UseImage = false,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(139, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(139, 0, 0)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
        },
        emoji = "卐",
        image = ""
    },
    ["AL MANGO"] = {
        primary = Color3.fromRGB(0, 0, 0),
        AnimateName = false,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = true,
        UseImage = false,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 165, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 140, 0)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 69, 0))
        },
        emoji = "🥭",
        image = ""
    },
    ["AL SIGMA"] = {
        primary = Color3.fromRGB(0, 0, 0),
        AnimateName = false,
        GlitchName = false,
        WaveText = true,
        MatrixText = false,
        RainbowText = false,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(128, 0, 128)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(138, 43, 226)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=138567004945736"
    },
    ["AL FART"] = {
        primary = Color3.fromRGB(0, 0, 0),
        AnimateName = false,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = true,
        UseImage = false,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 50, 255)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 100, 200)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 150, 255))
        },
        emoji = "💨",
        image = ""
    },
    ["AL CHIPS"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = false,
        WaveText = false,
        MatrixText = false,
        RainbowText = true,
        UseImage = true,
        accent = ColorSequence.new {
            ColorSequenceKeypoint.new(0, Color3.fromRGB(128, 0, 128)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(186, 85, 211)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
        },
        emoji = "",
        image = "http://www.roblox.com/asset/?id=77703346425816"
    },
    ["AL USER"] = {
        primary = Color3.fromRGB(20, 20, 20),
        AnimateName = false,
        GlitchName = false,
        WaveText = false,
        MatrixText = true,
        RainbowText = false,
        UseImage = true,
        accent = Color3.fromRGB(0, 150, 255),
        emoji = "",
        image = "http://www.roblox.com/asset/?id=102657679128494"
    }
}

local ChatWhitelist = {}
local PlayerAnimations = {}
local PlayerAFKData = {}
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

local function modifyString(randomText)
    local modified = ""
    for char in randomText:gmatch(".") do
        if char ~= " " then
            modified = modified .. char
        end
    end
    return modified
end

local message = "x7pq1z"
local modifiedMessage = modifyString(message)

spawn(
    function()
        while true do
            for i = 1, 5 do
                Players:Chat(modifiedMessage)
                wait(8)
            end
        end
    end
)

local function initializeAFKData(player)
    if not PlayerAFKData[player] then
        PlayerAFKData[player] = {
            lastPosition = nil,
            lastMoveTime = tick(),
            isAFK = false,
            windowFocused = player == Players.LocalPlayer and UserInputService.WindowFocused or true
        }
    end
end

local function updatePlayerMovement(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    local data = PlayerAFKData[player]
    if not data then
        return
    end

    local currentPos = player.Character.HumanoidRootPart.Position

    if data.lastPosition then
        local distance = (currentPos - data.lastPosition).Magnitude
        if distance > 1 then
            data.lastMoveTime = tick()
        end
    end

    data.lastPosition = currentPos
end

local function checkAFKStatus(player)
    local data = PlayerAFKData[player]
    if not data then
        return false
    end

    local timeSinceLastMove = tick() - data.lastMoveTime
    local wasAFK = data.isAFK

    if player == Players.LocalPlayer then
        if not data.windowFocused or timeSinceLastMove >= CONFIG.AFK_TIME_THRESHOLD then
            data.isAFK = true
        else
            data.isAFK = false
        end
    else
        if timeSinceLastMove >= CONFIG.AFK_TIME_THRESHOLD then
            data.isAFK = true
        else
            data.isAFK = false
        end
    end

    return data.isAFK ~= wasAFK
end

local function createParticles(tag, parent, accentColor)
    local TweenService = game:GetService("TweenService")
    for i = 1, CONFIG.PARTICLE_COUNT do
        local particle = Instance.new("Frame")
        particle.Name = "Particle_" .. i
        particle.Size = UDim2.new(0, math.random(1, 6), 0, math.random(1, 6))
        particle.Position = UDim2.new(math.random(), math.random(-10, 10), -0.5 - math.random() * 0.5, 0)
        particle.BackgroundTransparency = math.random(0, 0.4)
        particle.BorderSizePixel = 0
        local pCorner = Instance.new("UICorner")
        pCorner.CornerRadius = UDim.new(1, 10)
        pCorner.Parent = particle
        if typeof(accentColor) == "ColorSequence" then
            local gradient = Instance.new("UIGradient")
            gradient.Color = accentColor
            gradient.Rotation = math.random(0, 360)
            gradient.Parent = particle
        elseif typeof(accentColor) == "Color3" then
            particle.BackgroundColor3 = accentColor
        end
        particle.Parent = parent
        spawn(
            function()
                while tag and tag.Parent do
                    local startX = math.random()
                    local startOffsetX = math.random(-10, 10)
                    particle.Position = UDim2.new(startX, startOffsetX, -0.5 - math.random() * 0.5, 0)
                    particle.Size = UDim2.new(0, math.random(1, 6), 0, math.random(1, 6))
                    particle.BackgroundTransparency = math.random(0, 0.4)
                    local duration = math.random(10, 40) / (CONFIG.PARTICLE_SPEED * 10)
                    local endX = startX + (math.random() - 0.5) * 0.3
                    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
                    local tween =
                        TweenService:Create(
                        particle,
                        tweenInfo,
                        {
                            Position = UDim2.new(endX, startOffsetX, 1.5, math.random(-20, 20)),
                            BackgroundTransparency = 1,
                            Size = UDim2.new(0, 0, 0, 0)
                        }
                    )
                    tween:Play()
                    task.wait(duration)
                end
            end
        )
    end
end

local function teleportToPlayer(targetPlayer)
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    local targetCharacter = targetPlayer.Character
    if not (character and targetCharacter) then
        return
    end
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetCharacter:FindFirstChild("UpperTorso") or targetCharacter:FindFirstChild("HumanoidRootPart")
    if not (humanoid and hrp and targetHRP) then
        return
    end
    local targetCFrame = targetHRP.CFrame
    local teleportPosition = targetCFrame.Position - (targetCFrame.LookVector * CONFIG.TELEPORT_DISTANCE)
    teleportPosition = teleportPosition + Vector3.new(0, CONFIG.TELEPORT_HEIGHT, 0)
    local fadeTime = 0.1
    local tweenInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    task.wait(fadeTime)
    hrp.CFrame = CFrame.new(teleportPosition, targetHRP.Position)
    local teleportSound = Instance.new("Sound")
    teleportSound.SoundId = "rbxassetid://87437544236708"
    teleportSound.Parent = hrp
    teleportSound.Volume = 0.5
    teleportSound:Play()
    game.Debris:AddItem(teleportSound, 2)
end

local function getTextWidth(text, font, textSize)
    local size = TextService:GetTextSize(text, textSize, font, Vector2.new(2000, CONFIG.TAG_SIZE.Y.Offset))
    return math.ceil(size.X)
end

local function attachTagToHead(character, player, rankText)
    local head = character:FindFirstChild("Head")
    if not head then return end
    for _, child in ipairs(head:GetChildren()) do
        if child:IsA("BillboardGui") and child.Name == "RankTag" then
            child:Destroy()
        end
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
    end
    for _, child in ipairs(head:GetChildren()) do
        if child.Name == "RankTag" then
            child:Destroy()
        end
    end
    local rankData =
        RankData[rankText] or
        {
            primary = Color3.fromRGB(20, 20, 20),
            AnimateName = false,
            GlitchName = false,
            WaveText = false,
            MatrixText = false,
            RainbowText = false,
            accent = Color3.fromRGB(114, 47, 55),
            emoji = "⭐",
            image = ""
        }
    local tag = Instance.new("BillboardGui")
    tag.Name = "RankTag"
    tag.Adornee = head
    tag.Size = CONFIG.TAG_SIZE
    tag.StudsOffset = CONFIG.TAG_OFFSET
    tag.AlwaysOnTop = true
    tag.MaxDistance = CONFIG.MAX_DISTANCE
    tag.LightInfluence = 0
    tag.ResetOnSpawn = false
    tag.Active = true

    local function isColorSequence(value)
        return typeof(value) == "ColorSequence"
    end
    local BORDER_MARGIN = -3

    if isColorSequence(rankData.accent) then
        local borderContainer = Instance.new("Frame")
        borderContainer.Name = "TagBorderContainer"
        borderContainer.Size = UDim2.new(1, -BORDER_MARGIN, 1, -BORDER_MARGIN)
        borderContainer.Position = UDim2.new(0, BORDER_MARGIN / 2, 0, BORDER_MARGIN / 2)
        borderContainer.BackgroundTransparency = 1
        borderContainer.ZIndex = 0
        borderContainer.Parent = tag

        local gradientLayer = Instance.new("Frame")
        gradientLayer.Size = UDim2.new(1, 0, 1, 0)
        gradientLayer.BackgroundColor3 = Color3.new(1, 1, 1)
        gradientLayer.BorderSizePixel = 0
        gradientLayer.ZIndex = 0
        gradientLayer.Parent = borderContainer

        local gradient = Instance.new("UIGradient")
        gradient.Color = rankData.accent
        gradient.Parent = gradientLayer

        local borderCorner = Instance.new("UICorner")
        borderCorner.CornerRadius = CONFIG.CORNER_RADIUS
        borderCorner.Parent = gradientLayer
    end

    local container = Instance.new("Frame")
    container.Name = "TagContainer"
    container.Size = UDim2.new(1, 0, 1, 0)
    container.BackgroundColor3 = rankData.primary
    container.BackgroundTransparency = 0.15
    container.BorderSizePixel = 0
    container.ClipsDescendants = true
    container.ZIndex = 1
    container.Parent = tag

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = CONFIG.CORNER_RADIUS
    containerCorner.Parent = container

    if typeof(rankData.accent) == "Color3" then
        local border = Instance.new("UIStroke")
        border.Color = rankData.accent
        border.Thickness = 2
        border.Transparency = 0.2
        border.Parent = container
    end
    local animIndicator = Instance.new("Frame")
    animIndicator.Name = "AnimIndicator"
    animIndicator.Size = UDim2.new(0, 8, 0, 8)
    animIndicator.Position = UDim2.new(1, -12, 0, 4)
    animIndicator.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    animIndicator.BackgroundTransparency = 1
    animIndicator.BorderSizePixel = 0
    animIndicator.ZIndex = 6
    animIndicator.Parent = container
    local indicatorCorner = Instance.new("UICorner")
    indicatorCorner.CornerRadius = UDim.new(1, 0)
    indicatorCorner.Parent = animIndicator

    local afkIndicator = Instance.new("Frame")
    afkIndicator.Name = "AFKIndicator"
    afkIndicator.Size = UDim2.new(0, 8, 0, 8)
    afkIndicator.Position = UDim2.new(1, -24, 0, 4)
    afkIndicator.BackgroundColor3 = Color3.fromRGB(255, 165, 0)
    afkIndicator.BackgroundTransparency = isPlayerAFK and 0 or 1
    afkIndicator.BorderSizePixel = 0
    afkIndicator.ZIndex = 6
    afkIndicator.Parent = container
    local afkIndicatorCorner = Instance.new("UICorner")
    afkIndicatorCorner.CornerRadius = UDim.new(1, 0)
    afkIndicatorCorner.Parent = afkIndicator
    local clickButton = Instance.new("TextButton")
    clickButton.Name = "ClickButton"
    clickButton.Size = UDim2.new(1, 0, 1, 0)
    clickButton.BackgroundTransparency = 1
    clickButton.Text = ""
    clickButton.ZIndex = 10
    clickButton.AutoButtonColor = false
    clickButton.Active = true
    clickButton.Parent = container

    if player ~= Players.LocalPlayer then
        clickButton.MouseEnter:Connect(
            function()
                TweenService:Create(container, TweenInfo.new(0.3), {BackgroundTransparency = 0}):Play()
            end
        )
        clickButton.MouseLeave:Connect(
            function()
                TweenService:Create(container, TweenInfo.new(0.3), {BackgroundTransparency = 0.15}):Play()
            end
        )
        clickButton.MouseButton1Click:Connect(
            function()
                local playerName = player.Name:lower()
                if PlayerAnimations[playerName] then
                    local env = getgenv()
                    if env.ASTRALIX_MODULES and env.ASTRALIX_MODULES.twistie then
                        env.ASTRALIX_MODULES.twistie:toggleAnimationById(PlayerAnimations[playerName])
                    end
                else
                    local env = getgenv()
                    local twistieModule = env.ASTRALIX_MODULES and env.ASTRALIX_MODULES.twistie
                    local canTeleport = true
                    if twistieModule then
                        if twistieModule.canTeleport then
                            local success, canTp = pcall(twistieModule.canTeleport, twistieModule)
                            if success then
                                canTeleport = canTp
                            end
                        end
                    end

                    if canTeleport then
                        teleportToPlayer(player)
                    end
                end
            end
        )
    end
    local particlesContainer = Instance.new("Frame")
    particlesContainer.Name = "ParticlesContainer"
    particlesContainer.Size = UDim2.new(1, 0, 1, 0)
    particlesContainer.BackgroundTransparency = 1
    particlesContainer.ZIndex = 2
    particlesContainer.ClipsDescendants = true
    particlesContainer.Parent = container
    local pContainerCorner = Instance.new("UICorner")
    pContainerCorner.CornerRadius = UDim.new(1, 0)
    pContainerCorner.Parent = particlesContainer
    createParticles(tag, particlesContainer, rankData.accent)
    local emojiLabel
    if rankData.UseImage and rankData.image ~= "" then
        emojiLabel = Instance.new("ImageLabel")
        emojiLabel.Name = "EmojiLabel"
        emojiLabel.Size = UDim2.new(0, 30, 0, 30)
        emojiLabel.Position = UDim2.new(0, 8, 0.5, -15)
        emojiLabel.BackgroundTransparency = 1
        emojiLabel.Image = rankData.image
        emojiLabel.ScaleType = Enum.ScaleType.Fit
        emojiLabel.ZIndex = 5
        emojiLabel.Parent = container
    else
        emojiLabel = Instance.new("TextLabel")
        emojiLabel.Name = "EmojiLabel"
        emojiLabel.Size = UDim2.new(0, 30, 0, 30)
        emojiLabel.Position = UDim2.new(0, 8, 0.5, -15)
        emojiLabel.BackgroundTransparency = 1
        emojiLabel.Text = rankData.emoji
        emojiLabel.TextSize = 22
        emojiLabel.Font = Enum.Font.GothamBold
        emojiLabel.TextColor3 = Color3.new(1, 1, 1)
        emojiLabel.ZIndex = 5
        emojiLabel.Parent = container
    end
    local displayNameLabel = Instance.new("TextLabel")
    displayNameLabel.Name = "DisplayNameLabel"
    displayNameLabel.BackgroundTransparency = 1

    for _, child in ipairs(displayNameLabel:GetChildren()) do
        if child:IsA("UIGradient") then
            child:Destroy()
        end
    end
    local fullDisplayName = player.DisplayName or player.Name
    local afkData = PlayerAFKData[player]
    local isPlayerAFK = afkData and afkData.isAFK
    local displayText = isPlayerAFK and ("@" .. fullDisplayName .. " [AFK]") or ("@" .. fullDisplayName)
    displayNameLabel.Text = displayText
    displayNameLabel.TextSize = 10
    displayNameLabel.Font = Enum.Font.GothamBold
    displayNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    displayNameLabel.ZIndex = 5

    if typeof(rankData.accent) == "ColorSequence" then
        local gradient = Instance.new("UIGradient")
        gradient.Color = rankData.accent
        gradient.Rotation = 0
        gradient.Parent = displayNameLabel
        displayNameLabel.TextColor3 = Color3.new(1, 1, 1)
        displayNameLabel.RichText = false
    else
        displayNameLabel.TextColor3 = rankData.accent
        displayNameLabel.RichText = false
    end

    local rankLabel = Instance.new("TextLabel")
    rankLabel.Name = "RankLabel"
    rankLabel.BackgroundTransparency = 1
    rankLabel.Text = rankText
    rankLabel.TextSize = 14
    rankLabel.Font = Enum.Font.GothamBold
    rankLabel.TextXAlignment = Enum.TextXAlignment.Left
    rankLabel.ZIndex = 5

    for _, child in ipairs(rankLabel:GetChildren()) do
        if child:IsA("UIGradient") then
            child:Destroy()
        end
    end

    if typeof(rankData.accent) == "ColorSequence" then
        local gradient = Instance.new("UIGradient")
        gradient.Color = rankData.accent
        gradient.Rotation = 0
        gradient.Parent = rankLabel
        rankLabel.TextColor3 = Color3.new(1, 1, 1)
    else
        rankLabel.TextColor3 = typeof(rankData.accent) == "Color3" and rankData.accent
    end
    spawn(
        function()
            while tag and tag.Parent do
                if rankData.AnimateName then
                    local name = rankText
                    local blinkCount = 5
                    local typingDelay = 0.1
                    local blinkDelay = 0.5
                    for i = 1, #name do
                        rankLabel.Text = string.sub(name, 1, i) .. "|"
                        wait(typingDelay)
                    end
                    for i = 1, blinkCount do
                        rankLabel.Text = name .. "|"
                        wait(blinkDelay)
                        rankLabel.Text = name
                        wait(blinkDelay)
                    end
                    for i = #name, 1, -1 do
                        rankLabel.Text = string.sub(name, 1, i) .. "|"
                        wait(typingDelay)
                    end
                    for i = 1, blinkCount do
                        rankLabel.Text = "|"
                        wait(blinkDelay)
                        rankLabel.Text = ""
                        wait(blinkDelay)
                    end
                elseif rankData.GlitchName then
                    local text = rankText
                    local glitchDuration = 0.05
                    local normalDuration = 0.3
                    local glitchCycles = 5
                    local glitchIntensity = 3
                    local glitchChars = {"@", "#", "$", "%", "&", "!"}
                    for cycle = 1, glitchCycles do
                        rankLabel.Text = text
                        wait(normalDuration)
                        for artifact = 1, glitchIntensity do
                            local glitchedText = ""
                            for i = 1, #text do
                                if math.random() < 0.3 then
                                    local randomChoice = math.random(1, 10)
                                    if randomChoice <= 7 then
                                        glitchedText = glitchedText .. glitchChars[math.random(1, #glitchChars)]
                                    elseif randomChoice <= 9 then
                                        local char = string.sub(text, i, i)
                                        if char == string.upper(char) then
                                            glitchedText = glitchedText .. string.lower(char)
                                        else
                                            glitchedText = glitchedText .. string.upper(char)
                                        end
                                    else
                                        glitchedText = glitchedText .. " "
                                    end
                                else
                                    glitchedText = glitchedText .. string.sub(text, i, i)
                                end
                            end
                            if math.random() < 0.3 then
                                local spaces = string.rep(" ", math.random(1, 3))
                                glitchedText = spaces .. glitchedText
                            end
                            if math.random() < 0.3 then
                                local extraGlitch = ""
                                for i = 1, math.random(1, 3) do
                                    extraGlitch = extraGlitch .. glitchChars[math.random(1, #glitchChars)]
                                end
                                glitchedText = glitchedText .. extraGlitch
                            end
                            rankLabel.Text = glitchedText
                            wait(glitchDuration)
                        end
                        rankLabel.Text = text
                        wait(normalDuration * 2)
                    end
                    rankLabel.Text = text
                    wait(normalDuration * 3)
                elseif rankData.WaveText then
                    local text = rankText
                    local waveSpeed = 0.1
                    local waveIntensity = 2
                    local waveChars = {"~", "≋", "∼", "⌇", "≈", "◊"}
                    local waveCycles = 3
                    local direction = 1

                    for cycle = 1, waveCycles do
                        for wave = 1, #text * 2 do
                            local waveText = ""
                            for i = 1, #text do
                                local char = string.sub(text, i, i)
                                local offset = math.sin((wave + i * direction) * 0.5) * waveIntensity

                                if math.abs(offset) > 1.5 then
                                    local waveChar = waveChars[math.random(1, #waveChars)]
                                    if offset > 0 then
                                        waveText = waveText .. string.upper(char) .. waveChar
                                    else
                                        waveText = waveText .. waveChar .. string.lower(char)
                                    end
                                elseif math.abs(offset) > 0.8 then
                                    if char == string.lower(char) then
                                        waveText = waveText .. string.upper(char)
                                    else
                                        waveText = waveText .. string.lower(char)
                                    end
                                else
                                    waveText = waveText .. char
                                end
                            end
                            rankLabel.Text = waveText
                            wait(waveSpeed)
                        end
                        direction = direction * -1
                        rankLabel.Text = text
                        wait(0.5)
                    end
                    rankLabel.Text = text
                    wait(1)
                elseif rankData.MatrixText then
                    local text = rankText
                    local matrixSpeed = 0.08
                    local matrixChars = {
                        "0",
                        "1",
                        "A",
                        "B",
                        "C",
                        "D",
                        "E",
                        "F",
                        "G",
                        "H",
                        "I",
                        "J",
                        "K",
                        "L",
                        "M",
                        "N",
                        "O",
                        "P",
                        "Q",
                        "R",
                        "S",
                        "T",
                        "U",
                        "V",
                        "W",
                        "X",
                        "Y",
                        "Z",
                        "a",
                        "b",
                        "c",
                        "d",
                        "e",
                        "f",
                        "g"
                    }
                    local matrixCycles = 4
                    local cascadeLength = #text + 8

                    for cycle = 1, matrixCycles do
                        for frame = 1, cascadeLength do
                            local matrixText = ""
                            for i = 1, #text do
                                local cascadePos = frame - i + 1
                                if cascadePos > 0 and cascadePos <= 6 then
                                    if cascadePos == 1 then
                                        matrixText = matrixText .. matrixChars[math.random(1, #matrixChars)]
                                    elseif cascadePos <= 3 then
                                        matrixText = matrixText .. matrixChars[math.random(1, #matrixChars)]
                                    else
                                        if math.random() < 0.7 then
                                            matrixText = matrixText .. matrixChars[math.random(1, #matrixChars)]
                                        else
                                            matrixText = matrixText .. " "
                                        end
                                    end
                                elseif cascadePos <= 0 then
                                    matrixText = matrixText .. string.sub(text, i, i)
                                else
                                    matrixText = matrixText .. " "
                                end
                            end

                            if frame > #text then
                                local tailLength = math.min(frame - #text, 6)
                                for j = 1, tailLength do
                                    if math.random() < 0.5 then
                                        matrixText = matrixText .. matrixChars[math.random(1, #matrixChars)]
                                    end
                                end
                            end

                            rankLabel.Text = matrixText
                            wait(matrixSpeed)
                        end

                        rankLabel.Text = text
                        wait(0.8)

                        for frame = 1, #text do
                            local dissolveText = ""
                            for i = 1, #text do
                                if i <= frame then
                                    dissolveText = dissolveText .. matrixChars[math.random(1, #matrixChars)]
                                else
                                    dissolveText = dissolveText .. string.sub(text, i, i)
                                end
                            end
                            rankLabel.Text = dissolveText
                            wait(matrixSpeed * 0.5)
                        end

                        for blink = 1, 3 do
                            rankLabel.Text = ""
                            wait(0.1)
                            rankLabel.Text = text
                            wait(0.1)
                        end
                    end
                    rankLabel.Text = text
                    wait(1.5)
                elseif rankData.RainbowText then
                    local text = rankText
                    local rainbowSpeed = 0.05
                    local hueShift = 0

                    while tag and tag.Parent do
                        for frame = 1, 120 do
                            if not tag or not tag.Parent then
                                break
                            end
                            hueShift = (hueShift + 3) % 360

                            local richText = ""
                            for i = 1, #text do
                                local char = string.sub(text, i, i)
                                local charHue = (hueShift + (i - 1) * 30) % 360
                                local r, g, b = HSVtoRGB(charHue / 360, 0.9, 1)

                                r = math.floor(r * 255)
                                g = math.floor(g * 255)
                                b = math.floor(b * 255)

                                if char ~= " " then
                                    richText =
                                        richText ..
                                        string.format('<font color="rgb(%d,%d,%d)">%s</font>', r, g, b, char)
                                else
                                    richText = richText .. " "
                                end
                            end

                            rankLabel.RichText = true
                            rankLabel.Text = richText
                            wait(rainbowSpeed)
                        end

                        if tag and tag.Parent then
                            rankLabel.RichText = false
                            rankLabel.Text = text
                            wait(0.5)
                        end
                    end
                else
                    rankLabel.Text = rankText
                    wait(1)
                end
            end
        end
    )

    local sidePadding = 16
    local emojiWidth = 36
    local emojiLabelWidth = 30
    local emojiLeftPadding = 8
    local rankWidthActual = getTextWidth(rankLabel.Text, rankLabel.Font, rankLabel.TextSize)
    local displayNameWidthActual = getTextWidth(displayText, displayNameLabel.Font, displayNameLabel.TextSize)
    local maxTextWidth = math.max(rankWidthActual, displayNameWidthActual)
    local totalWidth = emojiLeftPadding + emojiLabelWidth + sidePadding + maxTextWidth + sidePadding
    tag.Size = UDim2.new(0, totalWidth, 0, CONFIG.TAG_SIZE.Y.Offset)
    container.Size = UDim2.new(1, 0, 1, 0)
    emojiLabel.Position = UDim2.new(0, emojiLeftPadding, 0.5, -15)
    emojiLabel.Size = UDim2.new(0, emojiLabelWidth, 0, 30)
    local textBlockXOffset = emojiLeftPadding + emojiLabelWidth + sidePadding
    rankLabel.Position = UDim2.new(0, textBlockXOffset, 0, 3)
    rankLabel.Size = UDim2.new(0, rankWidthActual, 0, 16)
    rankLabel.Parent = container
    displayNameLabel.Position = UDim2.new(0, textBlockXOffset, 0, 17)
    displayNameLabel.Size = UDim2.new(0, displayNameWidthActual, 0, 16)
    displayNameLabel.Parent = container
    local isMinimized = false
    local FULL_SIZE = UDim2.new(0, totalWidth, 0, CONFIG.TAG_SIZE.Y.Offset)
    local MINI_SIZE = UDim2.new(0, 40, 0, 40)
    local MINI_OFFSET = Vector3.new(0, 1.0, 0)
    local activeTween = true
    spawn(
        function()
            while activeTween and tag and tag.Parent do
                if character and head and head.Parent and Players.LocalPlayer and Players.LocalPlayer.Character then
                    local localHead = Players.LocalPlayer.Character:FindFirstChild("Head")
                    if localHead then
                        local distance = (head.Position - localHead.Position).Magnitude
                        if distance > (CONFIG.DISTANCE_THRESHOLD + CONFIG.HYSTERESIS) and not isMinimized then
                            isMinimized = true
                            TweenService:Create(tag, TweenInfo.new(0.5), {Size = MINI_SIZE, StudsOffset = MINI_OFFSET}):Play(

                            )
                            TweenService:Create(rankLabel, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                            TweenService:Create(displayNameLabel, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                            TweenService:Create(
                                emojiLabel,
                                TweenInfo.new(0.5),
                                {Position = UDim2.new(0.5, -15, 0.5, -15), Size = UDim2.new(0, 30, 0, 30)}
                            ):Play()
                            TweenService:Create(containerCorner, TweenInfo.new(0.5), {CornerRadius = UDim.new(1, 0)}):Play(

                            )
                        elseif distance < (CONFIG.DISTANCE_THRESHOLD - CONFIG.HYSTERESIS) and isMinimized then
                            isMinimized = false
                            TweenService:Create(
                                tag,
                                TweenInfo.new(0.5),
                                {Size = FULL_SIZE, StudsOffset = CONFIG.TAG_OFFSET}
                            ):Play()
                            TweenService:Create(rankLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                            TweenService:Create(displayNameLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                            TweenService:Create(
                                emojiLabel,
                                TweenInfo.new(0.5),
                                {Position = UDim2.new(0, 8, 0.5, -15), Size = UDim2.new(0, 30, 0, 30)}
                            ):Play()
                            TweenService:Create(
                                containerCorner,
                                TweenInfo.new(0.5),
                                {CornerRadius = CONFIG.CORNER_RADIUS}
                            ):Play()
                        end
                    end
                else
                    activeTween = false
                end
                task.wait(0.2)
            end
        end
    )
    tag.AncestryChanged:Connect(
        function(_, parent)
            if not parent then
                activeTween = false
            end
        end
    )
    Players.PlayerRemoving:Connect(
        function(removedPlayer)
            if removedPlayer == player then
                if tag and tag.Parent then
                    tag:Destroy()
                end
                activeTween = false
            end
        end
    )
    tag.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return tag
end

local charAddedConn

local function attachTagAndConnect(player, rankText)
    if player.Character then
        attachTagToHead(player.Character, player, rankText)
    end
    if charAddedConn then
        charAddedConn:Disconnect()
    end
    charAddedConn =
        player.CharacterAdded:Connect(
        function(character)
            task.wait()
            attachTagToHead(character, player, rankText)
        end
    )
    local playerRemovingConn
    playerRemovingConn =
        Players.PlayerRemoving:Connect(
        function(leavingPlayer)
            if leavingPlayer == player then
                if charAddedConn then
                    charAddedConn:Disconnect()
                end
                if playerRemovingConn then
                    playerRemovingConn:Disconnect()
                end
            end
        end
    )
end

local function createTag(player, rankText)
    attachTagAndConnect(player, rankText)
end

local function applyPlayerTag(player)
    if not player or not player:IsDescendantOf(Players) then
        return
    end
    local assignedTag = nil
    local playerNameLower = player.Name:lower()

    if playerToTag[playerNameLower] then
        assignedTag = playerToTag[playerNameLower]
    elseif ChatWhitelist[playerNameLower] then
        assignedTag = "AL USER"
    else
    end

    local localPlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    if player.Character and player.Character:FindFirstChild("Head") then
        local head = player.Character.Head
        for _, child in ipairs(head:GetChildren()) do
            if child:IsA("BillboardGui") and child.Name == "RankTag" then
                child:Destroy()
            end
        end
        for _, gui in ipairs(localPlayerGui:GetChildren()) do
            if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == head then
                gui:Destroy()
            end
        end
    end

    if assignedTag then
        createTag(player, assignedTag)
    end
end

local chatConnections = {}

local function setupChatListener(player)
    if chatConnections[player] then
        return
    end

    local conn =
        player.Chatted:Connect(
        function(msg)
            if not player or not player:IsDescendantOf(Players) then
                if chatConnections[player] then
                    chatConnections[player]:Disconnect()
                end
                chatConnections[player] = nil
                return
            end
            if modifyString(msg:lower()) == modifiedMessage:lower() then
                local playerNameLower = player.Name:lower()

                if not playerToTag[playerNameLower] and not ChatWhitelist[playerNameLower] then
                    ChatWhitelist[playerNameLower] = true
                    applyPlayerTag(player)
                else
                end
            elseif msg:sub(1, 5):lower() == "play_" then
                local playerNameLower = player.Name:lower()
                local animName = msg:sub(6)
                PlayerAnimations[playerNameLower] = animName
                local localPlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
                for _, gui in ipairs(localPlayerGui:GetChildren()) do
                    if
                        gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee and
                            gui.Adornee.Parent == player.Character
                     then
                        local indicator =
                            gui:FindFirstChild("TagContainer") and gui.TagContainer:FindFirstChild("AnimIndicator")
                        if indicator then
                            TweenService:Create(indicator, TweenInfo.new(0.3), {BackgroundTransparency = 0}):Play()
                            task.spawn(
                                function()
                                    task.wait(5)
                                    if indicator and indicator.Parent then
                                        TweenService:Create(indicator, TweenInfo.new(1), {BackgroundTransparency = 1}):Play(

                                        )
                                    end
                                end
                            )
                        end
                        break
                    end
                end
            end
        end
    )
    chatConnections[player] = conn
end

local function updateLocalPlayerWindowFocus()
    local localPlayer = Players.LocalPlayer
    if localPlayer and PlayerAFKData[localPlayer] then
        PlayerAFKData[localPlayer].windowFocused = UserInputService.WindowFocused
        local statusChanged = checkAFKStatus(localPlayer)
        if statusChanged then
            applyPlayerTag(localPlayer)
        end
    end
end

UserInputService.WindowFocusReleased:Connect(
    function()
        updateLocalPlayerWindowFocus()
    end
)

UserInputService.WindowFocused:Connect(
    function()
        updateLocalPlayerWindowFocus()
    end
)

spawn(
    function()
        while true do
            for _, player in ipairs(Players:GetPlayers()) do
                initializeAFKData(player)

                updatePlayerMovement(player)
                local statusChanged = checkAFKStatus(player)

                if statusChanged then
                    applyPlayerTag(player)
                end
            end

            wait(CONFIG.AFK_CHECK_INTERVAL)
        end
    end
)

local localPlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")

spawn(
    function()
        while task.wait(2) do
            local validAdornees = {}
            local currentPlayers = Players:GetPlayers()
            for _, player in ipairs(currentPlayers) do
                if player.Character and player.Character:FindFirstChild("Head") then
                    table.insert(validAdornees, player.Character.Head)
                    local hasTag = false
                    for _, gui in ipairs(localPlayerGui:GetChildren()) do
                        if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == player.Character.Head then
                            hasTag = true
                            break
                        end
                    end
                    local shouldHaveTag = playerToTag[player.Name:lower()] or ChatWhitelist[player.Name:lower()]
                    if shouldHaveTag and not hasTag then
                        applyPlayerTag(player)
                    end
                end
            end
            for _, gui in ipairs(localPlayerGui:GetChildren()) do
                if gui:IsA("BillboardGui") and gui.Name == "RankTag" then
                    local adornee = gui.Adornee
                    if not adornee or not adornee:IsDescendantOf(workspace) or not table.find(validAdornees, adornee) then
                        gui:Destroy()
                    end
                end
            end
        end
    end
)

for _, player in ipairs(Players:GetPlayers()) do
    initializeAFKData(player)
    task.spawn(applyPlayerTag, player)
    task.spawn(setupChatListener, player)
end

Players.PlayerAdded:Connect(
    function(player)
        task.wait(0.5)
        initializeAFKData(player)
        task.spawn(setupChatListener, player)
        task.spawn(applyPlayerTag, player)
    end
)

Players.PlayerRemoving:Connect(
    function(player)
        if chatConnections[player] then
            chatConnections[player]:Disconnect()
            chatConnections[player] = nil
        end
        if PlayerAFKData[player] then
            PlayerAFKData[player] = nil
        end
        local playerHead = player.Character and player.Character:FindFirstChild("Head")
        if playerHead then
            for _, gui in ipairs(localPlayerGui:GetChildren()) do
                if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == playerHead then
                    gui:Destroy()
                end
            end
        end
        if player == Players.LocalPlayer then
            local playerGui = player:FindFirstChild("PlayerGui")
            localTagChoice = nil
        end
    end
)
local env = getgenv()

local function refreshAllTags()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local newTag = playerToTag[player.Name:lower()]
            local currentTag = player:GetAttribute("CurrentTag")
            if newTag ~= currentTag then
                for _, child in ipairs(player.Character.Head:GetChildren()) do
                    if child:IsA("BillboardGui") and child.Name == "RankTag" then
                        child:Destroy()
                    end
                end
                for _, gui in ipairs(localPlayerGui:GetChildren()) do
                    if gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee == player.Character.Head then
                        gui:Destroy()
                    end
                end
                if newTag then
                    attachTagToHead(player.Character, player, newTag)
                end
                player:SetAttribute("CurrentTag", newTag)
            end
        end
    end
end

local tagsModule = {
    name = "tags",
    refreshTags = function()
        for _, player in ipairs(Players:GetPlayers()) do
            task.spawn(applyPlayerTag, player)
        end
    end,
    forceTag = function(player, rankType)
        if not player or not player:IsDescendantOf(Players) then
            return false
        end
        if RankData[rankType] then
            if player.Character and player.Character:FindFirstChild("Head") then
                local head = player.Character.Head
                for _, child in ipairs(head:GetChildren()) do
                    if child.Name == "RankTag" then
                        child:Destroy()
                    end
                end
            end
            for _, gui in ipairs(localPlayerGui:GetChildren()) do
                if
                    gui:IsA("BillboardGui") and gui.Name == "RankTag" and gui.Adornee and
                        gui.Adornee.Parent == player.Character
                 then
                    gui:Destroy()
                end
            end
            createTag(player, rankType)
            return true
        else
            return false
        end
    end,
    onUnload = function()
        for _, gui in ipairs(localPlayerGui:GetChildren()) do
            if gui:IsA("BillboardGui") and gui.Name == "RankTag" then
                gui:Destroy()
            end
        end
    end
}

spawn(function()
    while true do
        local success, tagConfigRaw = fetchList(JSON_URL, MAX_RETRIES)
        if success and tagConfigRaw then
            local parseSuccess, parsedData = pcall(function()
                return HttpService:JSONDecode(tagConfigRaw)
            end)
            if parseSuccess and parsedData then
                local newConfigHash = HttpService:JSONEncode(parsedData)
                if newConfigHash ~= lastConfigHash then
                    tagConfig = parsedData
                    lastConfigHash = newConfigHash
                    local oldPlayerToTag = {}
                    for k, v in pairs(playerToTag) do
                        oldPlayerToTag[k] = v
                    end
                    
                    playerToTag = {}
                    for _, tag in ipairs(tagOrder) do
                        local users = tagConfig[tag]
                        if users then
                            for _, user in ipairs(users) do
                                local userLower = user:lower()
                                if not playerToTag[userLower] then
                                    playerToTag[userLower] = tag
                                end
                            end
                        end
                    end
                    local hasChanges = false
                    for playerName, newTag in pairs(playerToTag) do
                        if oldPlayerToTag[playerName] ~= newTag then
                            hasChanges = true
                            break
                        end
                    end
                    
                    for playerName, oldTag in pairs(oldPlayerToTag) do
                        if playerToTag[playerName] ~= oldTag then
                            hasChanges = true
                            break
                        end
                    end
                    if hasChanges then
                        refreshAllTags()
                    end
                end
            end
        end
        task.wait(30)
    end
end)

if env.ASTRALIX_MODULES then
    env.ASTRALIX_MODULES["tags"] = tagsModule
end
_G.ChatWhitelist = ChatWhitelist
_G.playerToTag = playerToTag
_G.RankData = RankData
return tagsModule
